/*
*** Передача параметров!!! ***
* Существует 3 способа передать параметры в функцию:
* -По значению - By value;
* -По указателю - By pointer;
* -По ссылке - By reference;
* --------------------------------------------------------
* Обычно мы передаем параметры в функции по значению.
* При этом значения передаваемых переменных копируются в функцию,
* и если функциия изменяет эти значения, то изменения происходят
* с копиями переменных а не с самими переменными.
* --------------------------------------------------------
* Для того чтобы функциия могла изменять принятые переменные
* их нужно передать по указателю или по ссылке
* --------------------------------------------------------
* Передача параметров по указателю!!!
* Для того чтобы передать параметры в функциию по указателю
* принимаемые параметры в функции должны быть указателями
* Эти указатели в теле функциии нужно разаменовывать,
* чтобы получиить доступ к значениям переданных переменных.
* Кроме того при вызове функции нужно взять адреса передаваемых переменных.
*/

/*
* *** Указатель (Pointer) ***
* Это переменная, которая содержит адрес другой переменной.
* Адрес - это число длиной 4 Байта,
* означающее порядковый номер Байта в оперативной памяти.
* ---------------------------------------------------------------------------------
* & - Оператор взятия адреса (Address-of operator).
* Это унарный оператор, который возвращает адрес своего операнда.
* У & есть только префиксная форма записи (всегда ставится ПЕРЕД операндом).

* - Оператор разыменования (Dereference operator).
* Это унарный оператор, который возвращает значение по адресу.
* только при объявлении показывает, что объявляемая переменная - это указатель,
* во все остальных случаях она разыменовывает указатель.
* ---------------------------------------------------------------------------------
*/

/*
* *** Передача параметров по ссылке!!! ***
* ----------------------------------------------------
* Ссылка (Reference) - это переменная, которая содержит адрес другой переменной.
*
* Ссылка отличается от указателя тем что ее не нужно разаменовывать,
* компилятор сам это делает.
* Кроме того не нужно брять адррес переменной на которую она ссылается
* компилятор и это сам делает, но адрес хранящейся в ссылке не возможно изменить.
* Именно поэтому ссылку можно проинициализировать только при объявлении.

* Ссылки появилиись в языке С++ как упращенный вариант указателя.
* Ссылки применяются в основном для передачии параметров в функцию.
* Для того чтоб функция могла изменять переданные в нее переменные.
* Для того чтобы передать параметры в функцию по ссылке,
* принимаемые параметры функции должны быть ссылками,
* больше передача параметров по ссылке синтоксически ни чем
* не отличается от передачи параметров по значению.
* ----------------------------------------------------
* int - Int
* int* - Указатель на int
* int& - Ссылка на int
* ----------------------------------------------------
*/

/*
*** ТЕРНАРНЫЙ ОПЕРАТОР!!! ***
* if(Condition) - Условие это операция сравнения возвращают true либо false.
* if (i < index) buffer[i] = arr[i]; else buffer[i + 1] = arr[i];
* (i < index) ? buffer[i] = arr[i] : buffer[i + 1] = arr[i];
* if - это конструкция.
* ? : тернарный оператор это - оператор (оператор может быть частью выражения).
* Тернарный оператор возвращает одно из двух значений
* value1 или value2, в зависимости от условия (condition).
* value1 и value2 обязательно должны быть одного типа!!!
*/

/*
* *** Динамические массивы!!! ***
* -------------------------------------------------------------------------------------
* Indexes - ииндекся (номера элементов).
* Values - значение элементов.
* -------------------------------------------------------------------------------------
* Размер статического массива может быть задан только целочисленным константным значением
* и только во время написания кода.
* Размер статического массива не возможно изменить после компиляции.
* Размер же динамического массива может быть задан переменным значением
* во время выполнения программы.
* Предварительно эта переменная значения можно вычеслить или ввести с клавиатуры.
* Для того чтобы объявить динамический массив нужно объявить указатель
* и выделить память при помощи оператора "new".
* Оператор "new" выделяет память для n-элементов заданного типа,
* в данном слычае int, и возвращает адрес выделенной памяти.
* Этот адрес мы и записываем в наш указатель.
* Оператор "new" всегда выделяет непрерывный блок памяти.
* -------------------------------------------------------------------------------------
* Обращение к элементам массива!!!
* Обращаться к элементам динамического массива можно точно так же как к элементам
* статического массива, т.е. используя аррифметику указателей и оператор разыменования
* или же через оператор индексирования. И в том и другом случае доступ к элементам массива
* осуществляется за константное время поскольку сводится к операции сложения
* -------------------------------------------------------------------------------------
* Передача динамического массива в функцию!!!
* Динамический массив можно передать также как и статический массив.
* После того как динамический массив уже не нужен, его нужно удалить,
* чтобы осводить память которую он занимал и чтобы эту память можно было использовать в других целях.
* Для удаления динамического массива используется оператор delete.
* -------------------------------------------------------------------------------------
* Статическая память Stack!!!
* Stack (Стопка) - Это модель памяти, из которой последний записанный элемент
* считывается первым
* Динамическая память Heap (Куча) - Это куча свободной оперативной памяти в оперрационной системе.
* Статические массивы хранятся в статической памяти (Stack),
* а диинамические в динамической памяти (Heap).
* Оператор new фактически запрашивает память у операционной системы
* и если у OS есть непрерывный блок памяти нужного размера, то она его выделяет.
* В противном случае возникает исключение. После того как мы воспользовались памятью
* ее нужно вернуть обратно операциионной системе. Именно это и делает оператор delete.
* Оператор delete освобождает память по указанному адресу и обсолютно нечего ни делает.
* Если только выделять память и не когда ее не освобождать, то рано или поздно
* свободная оперативная память в OS закончится и это в свою очередь закончется
* крахом нашего приложения. OS аварийно завершит его работу.
*/

/*
*** ДВУМЕРНЫЕ ДИНАМИЧЕСКИЕ МАССИВЫ!!! ***
* В двумерном массиве есть строки и столбики.
* Чтобы объявить двумерный динамический массив,
* 1) нужно объявить указатель на указатель;
* 2) затем создать массив указателей;
* 3) и только после этого можно выделять память под строки двумерного массива.

*** ПЕРЕДАЧА ДВУМЕРНОГО ДИНАМИЧКЕСКОГО МАССИВА В ФУНКЦИЮ!!! ***
* Для того чтобы передать двумерный динамический массив в функцию
* достаточно чтобы функция принамала указатель на указатель.
*/

/*
* *** Git ***
* Ключевым понятием любой системы контроля версий является репозиторий.
* Репозиторий это хранилище. Он может включать в себя исходные файлы, текстовые файлы,
* картинки, звуковые файлы, в репозитории может хранится все что угодно,
* но в основном они предназначены для хранения исходных файлов приложений.
* Репозиторий - это самая обычная папка с файлами.
* Различают локальный репозиторий и удаленный.
* Еще одним ключевым понятием в системах контроля версий является Commit (принять решение).
* Commit - это контрольная точка в которой сохраняются все изменения на данный момент.
* На эту контрольную точку всегда можно вернуться, если что-то пошло не так.
* Commit - это снимок репозитория на какой-то момент времени,
* к этому снимку можно вернуться, в случае не удачных изменений.
* Локальным называют репозиторий на компьютере на локальном диске,
* а удаленным репозиторием на сервере или облочном хранилище.
*
* ***Ветка (Branch)***
* В любом репозитории есть как минимум одна ветка - это master.
* Master - это основная ветка в репозитории.
* Для того чтобы вносить какие-то изменения в рабочий код,
* создают другую ветку и вносят изменения в неё.
* Например test_branch - вносятся какие-то изменения.
* Если изменения удачные, то test_branch можно влить в master,
* т.е. выполнить команду слияния (Merge).
* Часто слияние выполняют при помощи PullRequest - запрос на слияние веток.
* Ветка может отрастать только от какого-то Commit.
* Git - система контроля версий.
*
* *** Шаблоны функций ***
* Шаблонной называется функция которая может работать с любым типом данных.
* Для того чтобы сделать функцию шаблонной, перед ней нужно создать шаблон.
* Шаблон создается следующим образом template<typename T>
* Где tamplate определяет создание шаблона.
* typename определяет имя шаблонного типа.
* T - это шаблонный тип данных.
* После создания шаблона любой принимаемый параметр функции
* и любая локальная переменная функции может быть шаблонного типа.
* Созданный шаблон существует лишь до точки с запятой после прототипа
* или же до закрывающей фигурной скобки реализации.

* Ошибка на этапе компановке unresolved external symbol - Неразрешонный внешний символ
* возникает когда список принимаемых параметров в протите и реализации функции отличается.
*/